# suibianba
https://www.csdn.net/tags/MtTacgysNjE1NjQtYmxvZwO0O0OO0O0O.html
一、实验目的
1.了解避免死锁的原理。
2.研究银行家算法的实现方法。
二、实验内容
编程实现银行家算法，语言不限。程序中设置资源向量和各个矩阵的元素个数及初始值，由用户通过输入界面输入某进程对各类资源的请求向量，由程序判断是否能为用户请求进行资源分配，并显示结果。
银行家算法的分析、设计与实现
（一）算法设计理论描述
银行家算法的基本思想是：始终保持系统处于安全状态，当进程提出资源请求时，系统先进行预分配，再判断系统分配后是否仍然处于安全状态。如果仍然处于安全状态，就进行实际分配；如果处于不安全状态，则撤销预分配、拒绝该进程的资源请求。
操作系统按照银行家指定的规则为进程分配资源，当进程首次申请资源时，测试对资源的最大需求量，如果系统现存的资源可以满足其最大需求量则按当前申请量分配资源，否则推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配，若没有超过在测试系统现存的资源能否满足该进程尚需的最大资源量，如果可以满足则按当前的申请量分配资源，否则也要推迟分配。
（二）数据结构模型及算法描述
1、需要用到的数据结构：
(1)int n,m; //进程总数n和资源种类数m
(2)int Pi; //发出请求向量的进程
(3)int Max[N][N]={0}; //各进程所需各类资源的最大需求
(4)int Available[N]={0}; //系统可用资源向量
(5)int Allocation[N][N]={0}; //各进程已分配资源
(6)int Need[N][N]={0}; //各进程还需要资源
(7)int Requesti[N]={0}; //进程的请求资源向量
(8)int temp[N]={0}; //存放安全序列
(9)int Work[N]={0}; //存放系统可提供使用资源，工作向量
(10)int Finish[N]={0}; //初始值均为0，表示系统是否有足够的资源分配给进程，当有足够资源时置为1
(11)char name[N]={0}; //资源的名称，可以根据设计定义成一维数组或二维数组
(12)int times = 0; //记录发出请求的次数
2、银行家算法描述：（进程Pi发出请求资源申请）
(1)如果Requesti[i]≤Need[Pi][i]，因为进程Pi所需要的资源数已经超过它所宣布的最大值，系统不安全，输出提示资源超过所宣布的最大值，即“请求资源大于该进程所需要的资源!”。
(2)如果Requesti[i]≤Available[i]，表示尚无足够资源，输出提示申请资源超出可利用的资源，系统不安全，即“可用资源不足，无法满足请求!”。
(前两点在函数Check_Need_Available_Requesti()中实现判断)
(3)若以上两个条件都满足则系统试探着将资源分配给申请的进程，并修改下面数据结构中的数值：(以下公式中的符号均与代码一致）
Available[j]= Available[j]- Requesti [j]；
Allocation[Pi][j]= Allocation[Pi][j]+ Requesti [j]；
Need[Pi][j]= Need[Pi][j]- Requesti [j]；
(4)预分配资源后，执行安全性检查，调用Check()函数检查此次资源分配后系统是否处于安全状态。若安全，才正式将资源分配给进程；如果系统不安全，恢复原来的资源分配状态，让该进程等待。
(5)注意：需要特别判断分配资源后当前进程的Need矩阵中对应Pi进程的行向量是否是零向量。如果是，需要进一步修改Available矩阵和Allocation矩阵，相当于进程Pi已经执行完，将所分配到的所有资源进行释放，进而执行下一个进程请求；如果不是，只分配资源，不释放已分配矩阵中的资源。
(6)全程用while循环语句实现输入字符Y/N判断用户是否继续进行资源申请，如果是，则按提示继续操作；如果不是，则显示本次请求次数，并退出系统。
3、安全性算法描述：
(1)设置两个向量：工作向量Work,它表示系统可提供给进程运行所需的各类资源数目，在执行安全性算法时，Work[i]=Available[i];用Finish向量来表示系统是否有足够的资源分配给进程使系统保持安全状态；开始时先初始化Finish[i]=0；当有足够资源分配给进程时，再令Finish[i]=1。
注意：为了防止在安全性算法检测时，改变可利用资源的原始数据，故定义一个临时一维数组t_Available[i]=Available[i]，在安全性算法检测中使用临时数组进行安全状态检查。
(2)从进程集合通过遍历中找到一个能满足下述条件的进程:(以下公式中的符号均与代码一致）
① Finish[i]=0;
② Need[i][j]≤Work[j];(在函数Check_Need_Work(i)中实现判断)
若找到，执行步骤(3)，并break本次循环；执行完n次后，执行步骤(4)。
(3)当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源：(以下公式中的符号均与代码一致）
Work[j]=Work[j] + Allocation[i][j];
Finish[i]=1; break;
go to step (2);
(4)如果所有进程的Finish[i]=1都满足，则表示系统处于安全状态，返回true，并输出一个安全序列；否则，系统处于不安全状态，返回false。

